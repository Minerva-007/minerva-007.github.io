---
layout: post
title:  "UIUCTF: reject 2 inject"
category: CTF
tags: DLL-injection reverse-engineering rev 
permalink: /UIUCTF-r2i
---
My first ever CTF, a look into DLL initializations, and some interesting views
<!--more-->
# Premise
After getting completely destroyed in Google CTF, I joined [JHDiscord team](https://ctftime.org/team/62434) for my 2nd CTF: [UIUCTF held by SIGPwny](https://ctftime.org/event/1600). The theme was a gallery of prompt-based generated images, and each displayed image had a challenge associated with it.
I captured a single flag in the event, and this is the writeup for that. I'll try other challs and share their writeups too (subject to motivation).

# Challenge: Reject to Inject

> "a sad little foal, cute, watery eyes, ultra detailed, octane render"

## Description

> Seems like the patient is afraid of needles. Can you go help him?

## Stats

| Info | Value  |
|-------|----------|
| Number of solves       | 36                    |
| Ending score           | 197pts                |
| category               | reverse engineering   |
| Platform               | Windows               |
| Provided files         | IV.dll                |

## Prior knowledge

### DLLs

The provided file is a dynamic link library, which consist of compiled functions, a symbol table to aid in exporting functions, and an initializer that is called when the DLL is loaded. The Linux equivalent are .so libraries, and these also feature their entry points.

### How DLL loading works

Windows provide two main functions, namely `LoadLibrary` and `GetProcAddr` in `kernel32.dll` to aid in loading and linking to DLLs. Whenever `LoadLibrary` is called, the function looks for the requested library, loads it into the memory if it is called for the first time, calls `DllMain` to let DLL handle file-specific initializations and checks, and returns the handle to caller program.
`GetProcAddr` then accepts a string and uses the symbol table to find the address of requested procedure. The caller program then calls the address to use the function.

> So, when reversing a DLL, following things are to be noted:
* What functions does it export?
* What is happening in the entry point function?

## Initial tests

### Symbol table

Retrieving symbol table using objdump, we get
> cmd> objdump -t iv.dll
> 
> iv.dll:	file format pei-x86-64
> 
> SYMBOL TABLE:
> no symbols

Hmmmmm, no symbols. That's strange for a DLL whose purpose is to export functions. This hints towards a DLL with code segment solely lying in DllMain.

### Using a DLL

Using a DLL requires a loader program. The following C++ code does this.

```C++
#include"windows.h"//for LoadLibrary and FreeLibrary
#include"stdlib.h" //for system
int main()
{
	HMODULE hm=LoadLibrary("IV.dll");
	FreeLibrary(hm);
	return 0;
}
```

Let's see the output for this program. Using g++ to compile,
> cmd> g++ load.cpp -o loader.exe
> 
> cmd> loader
> 
> Failed! 
> 
> Press any key to continue...

As guessing from previous results, the program only used `LoadLibrary` and we got console output. This hints more towards DllMain bearing the executable code and being our point of interest.

### strings
Running `strings` is a good idea for files, since that provides a list of inputs/output prompts that may occur in execution, and also produces the import-export tables which help in hinting at program functionality. Here's a selected output from the command.
> cmd> strings iv.dll
> 
> ...
> 
> \Room2004
> 
> \sigpwnie.exe
> 
> IS7WXGC726Z9JZMFPOKWQVMEPJCSU2FIMAC5N2VYIPGFJPCZPROPMYNL
> 
> Success
> 
> Failed!
> 
> pause
> 
> ...
> 
> D:\BACKUP\user\Downloads\nightdream\ref\rejecttoinject\final\src\IV\x64\Debug\IV.pdb
> 
> uiuctf{sorry_im_just_a_fake_flag}
> 
> CloseHandle
> 
> GetCurrentProcess
> 
> CreateThread
> 
> FreeLibraryAndExitThread
> 
> GetModuleFileNameA
> 
> KERNEL32.dll
> 
> MessageBoxA
> 
> USER32.dll
> 
> OpenProcessToken
> 
> GetUserProfileDirectoryW

Let's break this down piecewise.

From the loading test done priorly, we know that 'Failed!' is an output string. So, this section should be data header, and that makes `IS7WXGC726Z9JZMFPOKWQVMEPJCSU2FIMAC5N2VYIPGFJPCZPROPMYNL` the potential flag, albeit obfuscated. `/Room2004` and `/Sigpwnie.exe` seem to be a filepath and executable name, which could be the requirement of the DLL to load successfully. 

Lastly, there are calls to `GetUserProfileDirectoryW`, which returns user directory `C:\Users\user-name` as a UTF-16 string (the `W` in function name). `GetModuleFileName` returns the name of the base module (in context of a DLL: the loader program) as a string.

This opens a few things.

## Ghidra time
WIP.