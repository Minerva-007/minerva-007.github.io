---
layout: post
title:  "SparkCTF 2022"
category: CTF
tags: reverse-engineering rev 
permalink: /SparkCTF2022-1
---
Writeups for "ezpz1" and "ezpz2" SparkCTF 2022.
<!--more-->
# Premise
Mid-November, a good friend and teammate (Jeser) in Task_Hashed invited me to stir up some rev challenges for their upcoming SparkCTF 2022: a LAN CTF organized by Engineers Spark Club. I'll be honest: I'm glad to be a part of the technical team. It was a fun and unique experience.

Now let's see what did I make. I made three challenges, two for easy and one for hard category. This post is for easy challenges.

# Challenge: ezpz1

## Description

> The team was really late on schedules, so they decided to add code later.

You can access the binaries [here](https://github.com/Minerva-007/SparkCTF2022/tree/main/EzPz1).

## Solution

So, there is an ezpz1.exe. The filename gives it away that it is a Portable-Executable file for Windows. Loading on Ghidra gives some good results on `main()` function.

The following snippet from Ghidra's decompiler is of particular interest.
![main](\assets\images\Spark1-1.png)

From this snippet, some things are clear:
1. The process obtains a handle to itself.
2. `VirtualProtect()` is used. Even without digging into what `0x38` means in `OpenProcess()`, we get a hint that memory writes are about to be done.
3. `payload` is an 8 byte memory package XOR'd with `0x48`. We'll look into that soon.
4. `WriteProcessMemory()` writes `payload` to `pr`, the same place where `VirtualProtect()` operates. 
5. Most important give-away: `pr()`. `pr` is a function!

Let's dig into what `payload ^ 0x48` results in.

`0x48, 0x89, 0xC8, 0x48, 0x83, 0xF0, 0x69, 0xC3`

By using our trustworthy disassembler at defuse.ca, we get following result:

![disasm](\assets\images\Spark1-2.png)

Brushing up our knowledge on fastcall convention, RCX contains the first input and RAX contains the output, so this is equivalent to:

```c++
int pr(int x)
{
return x^0x69;
}
```

And there we have it. From the `for` loop, it can be seen that the output from `pr()` is again XOR'd with the counter `i`, so the complete encryption scheme is deduced.

Following small code is generated after obtaining the data from `ch` variable.

```c++
#include"stdio.h"

int main()
{
	char ch[]={ 0x0b, 0x50, 0x58, 0x0f, 0x5a, 0x0e, 0x5e, 0x57, 0x56, 0x01, 0x57, 0x5b, 0x5c, 0x00, 0x55, 0x56, 0x4c, 0x19, 0x42, 0x48, 0x1b, 0x4c, 0x4b, 0x1c, 0x47, 0x41, 0x47, 0x45, 0x10, 0x41, 0x4f, 0x44, 0x71, 0x70, 0x7a, 0x29, 0x79, 0x74, 0x7e, 0x7b, 0x77, 0x70, 0x7a, 0x75, 0x7c, 0x7c, 0x25, 0x74, 0x68, 0x6b, 0x6a, 0x3f, 0x6d, 0x6d, 0x39, 0x6a, 0x68, 0x63, 0x64, 0x34, 0x37, 0x37, 0x31, 0x32 };
	printf("SparkCTF{");
	for(int i=0;i<sizeof(ch);i++)
	{
		printf("%c",ch[i]^0x69^i);
	}
	printf("}\n");
	return 0;
}
```

And it will print the Flag!

# Challenge: ezpz2

## Description

> Hopscotch or something idk I never left my room.

You can access the binaries [here](https://github.com/Minerva-007/SparkCTF2022/tree/main/EzPz2).

## Solution

This is an elf file (Ghidra said so) and decompiling and preprocessing lands us into the `main()` function. 

![main](\assets\images\Spark1-3.png)

Interesting piece of code. Major interest is in `arr` and `selector()`. Let's decompile `selector()` and see what is there.
```c++
/* selector(int, char) */

int selector(int index,char chara)

{
  char cVar1;
  int iVar2;
  
  switch(index % 5) {
  case 0:
    cVar1 = one(chara);
    iVar2 = (int)cVar1;
    break;
  case 1:
    cVar1 = two(chara);
    iVar2 = (int)cVar1;
    break;
  case 2:
    cVar1 = three(chara);
    iVar2 = (int)cVar1;
    break;
  case 3:
    cVar1 = four(chara);
    iVar2 = (int)cVar1;
    break;
  case 4:
    cVar1 = five(chara);
    iVar2 = (int)cVar1;
    break;
  default:
    iVar2 = 0x45;
  }
  return iVar2;
}
```
Luckily, Ghidra converted the spaghetti of assembly code into a nice switch-case ladder. From this, we can note:

1. The remainder from `index` is obtained and is used in switch-case ladder.
2. `chara` is passed on to a different function in each case: conveniently named `one()`, `two()`, `three()`, `four()`, and `five()`.

Let's summarize what each function does, according to Ghidra, here:

### one

```c++
int one(char param_1)

{
  return (byte)param_1 + 1;
}

```

### two

```c++
byte two(char param_1)

{
  return param_1 ^ 0x73;
}
```

### three

```c++
void three(char param_1)

{
  four(param_1 + -0x56);
  return;
}

```

### four

```c++
byte four(char param_1)

{
  return param_1 ^ 0x7b;
}
```

### five

```c++
char five(char param_1)

{
  return param_1;
}

```

Armed with what every function does, and what is the underlying logic, we retrieve bytes from `arr` and write a solver.

```c++
#include"stdio.h"

int solve(int index, char ch)
{
	switch(index%5)
	{
		//Idea is to revert what is done in the above functions
		case 0: return ch-1;
		case 1: return ch^0x73;
		case 2: return (ch^0x7b) + 0x56;
		case 3: return ch^0x7b;
		case 4: return ch;
		default: return ch;
	}
	return ch;
}


int main()
{
	unsigned char arr[]={ 0x62, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0xa0, 0xff, 0xff, 0xff, 0x4f, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00, 0x77, 0x00, 0x00, 0x00, 0x4b, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x4d, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x6b, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x39, 0x00, 0x00, 0x00, 0x45, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0x4b, 0x00, 0x00, 0x00, 0x98, 0xff, 0xff, 0xff, 0x43, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x4a, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x98, 0xff, 0xff, 0xff, 0x48, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x6b, 0x00, 0x00, 0x00 };
	printf("SparkCTF{");
	for(int i=0;i<sizeof(arr)/4;i++)
	{
		printf("%c",solve(i,arr[i*4]));
	}
	printf("}\n");
	return 0;
}
```

And with that, the flag is nicely retrieved.


## [Back to Main Page](https://minerva-007.github.io/)

> Love it? Hate it? Queries? Get in touch and feel free to discuss!